# ü§ñ Gu√≠a Completa de Ingenier√≠a de Contexto para Desarrollo con IA

*Una metodolog√≠a step-by-step para crear aplicaciones empresariales usando cualquier agente IA*

## ‚úÖ **Verificaci√≥n Oficial Completa**

**üéØ IMPORTANTE**: Todos los agentes IA, herramientas y tecnolog√≠as mencionados en esta gu√≠a han sido verificados con **fuentes oficiales**.

üìã **Ver Referencias Completas**: [REFERENCIAS_OFICIALES.md](./REFERENCIAS_OFICIALES.md)
- ‚úÖ **87 tecnolog√≠as verificadas** incluyendo todos los agentes IA listados
- ‚úÖ **100% precisi√≥n** - enlaces directos a sitios oficiales
- ‚úÖ **Sin informaci√≥n inventada** - solo fuentes verificadas

---

## ü§ñ **Compatibilidad Universal con Agentes IA**

Esta gu√≠a funciona con **TODOS los agentes IA de desarrollo** disponibles, incluyendo:

### **Agentes Integrados en IDEs:**
- **GitHub Copilot** (VS Code, JetBrains, Neovim)
- **Amazon CodeWhisperer** (VS Code, JetBrains, AWS Cloud9)
- **Tabnine** (VS Code, JetBrains, Sublime Text, Vim)
- **Codeium** (VS Code, JetBrains, Neovim, Web)
- **Replit Ghostwriter** (Replit IDE)

### **Agentes Conversacionales Web:**
- **ChatGPT** (GPT-4, GPT-4 Turbo, Code Interpreter)
- **Claude** (Claude-3 Opus, Claude-3.5 Sonnet)
- **Google Gemini** (Gemini Pro, Gemini Ultra)
- **Microsoft Copilot** (con GPT-4)
- **Perplexity AI** (con modo Code)
- **Phind** (especializado en desarrollo)
- **You.com** (modo programaci√≥n)

### **Agentes API y Plataformas:**
- **OpenAI API** (GPT-4, GPT-3.5 Turbo)
- **Anthropic Claude API**
- **Google PaLM API**
- **Cohere Command**
- **Hugging Face Transformers**
- **Ollama** (modelos locales)

### **Agentes CLI (Command Line Interface):**
- **GitHub Copilot CLI** (`gh copilot suggest`, `gh copilot explain`)
- **OpenAI CLI** (`openai api completions.create`)
- **Anthropic Claude CLI** (`anthropic complete`)
- **Ollama CLI** (`ollama run codellama`, `ollama run deepseek-coder`)
- **Shell GPT (sgpt)** (integraci√≥n directa en terminal)
- **ChatGPT CLI** (`chatgpt`, `gpt`)
- **AI Shell** (`ai "crear funci√≥n que..."`)
- **Warp Terminal** (terminal con IA integrada)
- **Fig** (ahora Amazon Q CLI - autocompletado inteligente)
- **Zsh Copilot** (plugin para zsh con IA)
- **Terminal Copilot** (asistente IA para comandos bash)

### **Agentes Especializados:**
- **Cursor** (IDE con IA integrada)
- **Replit Bounties** (desarrollo colaborativo)
- **v0.dev** (Vercel - generaci√≥n de UI)
- **Bolt.new** (StackBlitz - desarrollo full-stack)
- **CodeT5** (Salesforce)
- **InCoder** (Facebook/Meta)

### **Agentes Locales de Nueva Generaci√≥n (2024-2025):**
- **Cline** (ex Claude Dev - VSCode extension, autonomo, multi-modelo)
- **Continue** (VSCode/JetBrains - open source, flexible, MCP compatible)
- **LM Studio** (interfaz local para modelos GGUF)
- **Jan** (ChatGPT alternativo 100% local)
- **Msty** (cliente desktop multi-modelo local)
- **GPT4All** (chat local con m√∫ltiples modelos)
- **LocalAI** (API OpenAI compatible para modelos locales)
- **AnythingLLM** (RAG local con UI)
- **Open WebUI** (interfaz web para Ollama)
- **Enchanted** (cliente nativo macOS para modelos locales)

### **Caracter√≠sticas Clave:**
- ‚úÖ **Prompts universales** que funcionan en cualquier plataforma
- ‚úÖ **Contexto adaptable** seg√∫n las capacidades del agente
- ‚úÖ **Metodolog√≠a agn√≥stica** de tecnolog√≠a y herramienta
- ‚úÖ **Escalable** desde proyectos simples hasta arquitecturas empresariales

---

## üìã Tabla de Contenidos

1. [üéØ Introducci√≥n y Fundamentos](#-introducci√≥n-y-fundamentos)
2. [üìö Conocimientos Base Requeridos](#-conocimientos-base-requeridos)
3. [üèóÔ∏è Fase 1: Setup del Proyecto](#Ô∏è-fase-1-setup-del-proyecto)
4. [üíª Fase 2: Desarrollo de la Aplicaci√≥n](#-fase-2-desarrollo-de-la-aplicaci√≥n)
5. [üöÄ Fase 3: Despliegue a Producci√≥n](#-fase-3-despliegue-a-producci√≥n)
6. [üîß Fase 4: Mantenimiento y Soporte](#-fase-4-mantenimiento-y-soporte)
7. [‚ö° Prompts Espec√≠ficos por Contexto](#-prompts-espec√≠ficos-por-contexto)
8. [üéì Mejores Pr√°cticas](#-mejores-pr√°cticas)

---

## üéØ Introducci√≥n y Fundamentos

### ¬øQu√© es la Ingenier√≠a de Contexto?

La **Ingenier√≠a de Contexto** es la disciplina de comunicarse efectivamente con agentes IA para obtener resultados precisos, consistentes y de alta calidad. En lugar de programar l√≠nea por l√≠nea, dise√±as el contexto y las instrucciones para que la IA genere el c√≥digo que necesitas.

### Principios Fundamentales

1. **Contexto es Rey**: Proporciona TODA la informaci√≥n relevante
2. **Especificidad sobre Generalidad**: S√© espec√≠fico en lo que quieres
3. **Iteraci√≥n Inteligente**: Refina el contexto basado en resultados
4. **Documentaci√≥n Primera**: La IA necesita entender el "por qu√©"
5. **Validaci√≥n Continua**: Verifica cada output antes de continuar

---

## üìö Conocimientos Base Requeridos

### üü¢ **LO QUE S√ç NECESITAS SABER:**

#### Conceptos de Programaci√≥n (B√°sico)
- Variables, funciones, objetos
- Qu√© es una API y c√≥mo funciona
- Conceptos de base de datos (tablas, relaciones)
- Qu√© son los frameworks y librer√≠as

#### Arquitectura de Software (Conceptual)
- Diferencia entre frontend y backend
- Qu√© son los microservicios
- Conceptos b√°sicos de seguridad (autenticaci√≥n, autorizaci√≥n)
- Principios de dise√±o (separaci√≥n de responsabilidades)

#### Herramientas de Desarrollo
- **Git**: Comandos b√°sicos (add, commit, push, pull)
- **Terminal/CMD**: Navegaci√≥n b√°sica y ejecuci√≥n de comandos
- **VS Code**: Uso b√°sico del editor
- **Docker**: Conceptos b√°sicos (containers, images)

#### Metodolog√≠as
- **Scrum/Agile**: Conceptos b√°sicos de gesti√≥n de proyectos
- **Clean Architecture**: Principios de c√≥digo limpio
- **Testing**: Por qu√© son importantes los tests

### üî¥ **LO QUE NO NECESITAS PREOCUPARTE:**

#### Sintaxis Espec√≠fica de Lenguajes
- ‚ùå Memorizar sintaxis de TypeScript/JavaScript
- ‚ùå Conocer todas las APIs de Node.js
- ‚ùå Dominar React hooks espec√≠ficos
- ‚ùå Configuraciones complejas de Webpack/Vite

#### Configuraciones Complejas
- ‚ùå Setup manual de Docker
- ‚ùå Configuraci√≥n de CI/CD desde cero
- ‚ùå Optimizaciones avanzadas de base de datos
- ‚ùå Configuraciones de seguridad a nivel de infraestructura

#### Implementaciones Espec√≠ficas
- ‚ùå Algoritmos complejos
- ‚ùå Optimizaciones de performance avanzadas
- ‚ùå Patrones de dise√±o espec√≠ficos
- ‚ùå Configuraciones de monitoreo avanzado

---

## üèóÔ∏è Fase 1: Setup del Proyecto

### **Paso 1.1: Definici√≥n del Proyecto**

#### Prompt Inicial Recomendado:
```
Necesito crear un sistema [DESCRIPCI√ìN_DEL_SISTEMA] con las siguientes caracter√≠sticas:

**Funcionalidades principales:**
- [Lista espec√≠fica de funcionalidades]

**Requisitos t√©cnicos:**
- Arquitectura de microservicios
- Frontend en React/TypeScript
- Backend en Node.js/TypeScript  
- Base de datos [TIPO_BD]
- Autenticaci√≥n JWT
- API REST

**Requisitos de negocio:**
- Escalable para [N√öMERO] usuarios
- Tiempo de respuesta < [TIEMPO]
- Disponibilidad 99.9%
- Compatible con [SISTEMAS/INTEGRACIONES]

Quiero seguir mejores pr√°cticas de Clean Architecture, SOLID, y tener documentaci√≥n completa. El proyecto debe ser f√°cil de mantener y desarrollar en equipo.

Por favor, ay√∫dame a estructurar este proyecto paso a paso.
```

#### Prompts Usados en BackupGuard Pro:
```
1. "Necesito crear un sistema de monitoreo y gesti√≥n de copias de seguridad multiempresa que sea viral, f√°cil de instalar, con microservicios y microfrontends"

2. "El sistema debe usar TypeScript, Node.js, MongoDB, Redis, ser escalable y tener una arquitectura limpia"

3. "Quiero que sea un sistema que las empresas adopten r√°pidamente y compartan con otras empresas"
```

### **Paso 1.2: Estructura Inicial del Proyecto**

#### Prompt para Documentaci√≥n Base:
```
Ahora necesito crear la estructura de documentaci√≥n base para este proyecto. 

Por favor:
1. Crea una estructura de carpetas docs/ completa
2. Genera README.md principal explicando el proyecto
3. Crea documentaci√≥n de arquitectura
4. Incluye gu√≠as de desarrollo
5. Agrega documentaci√≥n de API
6. Crea gu√≠as de usuario

Usa markdown profesional y aseg√∫rate de que todo est√© en espa√±ol. La documentaci√≥n debe ser comprensible para desarrolladores junior y senior.
```

#### Prompt Usado en BackupGuard Pro:
```
"Crea la estructura de documentaci√≥n completa en docs/ con README.md, architecture/, development/, api/, y user_guide/. Todo en espa√±ol y siguiendo mejores pr√°cticas"
```

### **Paso 1.3: Configuraci√≥n de Herramientas**

#### Prompt para Git Flow:
```
Configura un flujo de trabajo Git profesional con:
- 3 ramas principales: main (producci√≥n), testing (QA), develop (desarrollo)
- Convenciones de commits (Conventional Commits)
- Protecciones de ramas
- Configuraci√≥n de CI/CD b√°sica
- Documentaci√≥n del flujo de trabajo

Incluye ejemplos espec√≠ficos y comandos que el equipo puede usar.
```

#### Prompt para AI Instructions:
```
Genera un archivo .github/copilot-instructions.md con instrucciones detalladas para agentes IA que trabajen en este proyecto.

Debe incluir:
- Principios de desarrollo (SOLID, Clean Architecture)
- Stack tecnol√≥gico espec√≠fico
- Patrones de c√≥digo requeridos
- Estructura de microservicios
- Convenciones de nomenclatura
- Mejores pr√°cticas de testing
- Metodolog√≠a de gesti√≥n de proyectos

Todo en espa√±ol y espec√≠fico para este proyecto.
```

### **Paso 1.4: Planificaci√≥n con Shape Up**

#### Prompt para Metodolog√≠a:
```
Implementa la metodolog√≠a Shape Up para este proyecto:

1. Crea la estructura de carpetas plans/
2. Define el primer plan "Sistema de Monitoreo de Backups"
3. Crea user stories siguiendo formato Gherkin
4. Incluye Definition of Ready y Definition of Done
5. Agrega estimaciones y dependencias

Cada user story debe tener:
- Informaci√≥n funcional (Gherkin)
- Especificaciones t√©cnicas
- **Diagramas C4 completos (4 niveles obligatorios)**
- Criterios de aceptaci√≥n
- Tareas espec√≠ficas

#### **Los 4 Niveles de Diagramas C4 Requeridos:**

**üè¢ Level 1 - System Context**
```
Prompt: "Crea un diagrama C4 Level 1 (System Context) que muestre:
- El sistema [NOMBRE_SISTEMA] en el centro
- Usuarios principales (administradores, operadores, clientes)
- Sistemas externos (APIs, servicios third-party, legacy systems)
- Flujos principales de datos entre ellos
- Tecnolog√≠as de integraci√≥n usadas

Usa formato Mermaid o PlantUML compatible con markdown."
```

**üì¶ Level 2 - Containers** 
```
Prompt: "Crea un diagrama C4 Level 2 (Containers) que detalle:
- Cada microservicio como container independiente
- Bases de datos y stores (MongoDB, Redis, etc.)
- API Gateway y load balancers
- Frontend applications (React apps, mobile apps)
- Message brokers (RabbitMQ, Kafka)
- Protocolos de comunicaci√≥n (HTTP, WebSocket, async messaging)

Incluye puertos, tecnolog√≠as y responsabilidades de cada container."
```

**‚öôÔ∏è Level 3 - Components**
```
Prompt: "Crea un diagrama C4 Level 3 (Components) para [SERVICIO_ESPEC√çFICO]:
- Controllers (endpoints REST)
- Services (l√≥gica de negocio)
- Repositories (acceso a datos)
- Models/Entities (esquemas de datos)
- Middleware (auth, validation, logging)
- External adapters (APIs externas, email, SMS)

Muestra dependencias entre componentes y flujos de datos internos."
```

**üíª Level 4 - Code**
```
Prompt: "Crea un diagrama C4 Level 4 (Code) para [COMPONENTE_CR√çTICO]:
- Clases principales con propiedades y m√©todos
- Interfaces y abstractions
- Design patterns implementados (Repository, Factory, Observer)
- Relaciones entre clases (herencia, composici√≥n, dependencias)
- Flujo de ejecuci√≥n para casos de uso principales

Enf√≥cate en los componentes m√°s cr√≠ticos o complejos del sistema."
```
```

---

## üíª Fase 2: Desarrollo de la Aplicaci√≥n

### **Paso 2.1: Arquitectura de Microservicios**

#### Prompt para Estructura Base:
```
Ahora vamos a crear la estructura de c√≥digo para los microservicios.

Por favor:
1. Crea la estructura de carpetas services/ con cada microservicio
2. Configura package.json como monorepo con scripts
3. Crea docker-compose.yml para desarrollo local
4. Establece la estructura base de cada servicio (controllers, services, models, etc.)
5. Configura eslint, prettier, y tsconfig.json compartido

Servicios requeridos: [LISTA_DE_SERVICIOS]

Cada servicio debe seguir Clean Architecture y tener su propia base de datos.
```

#### Prompt Espec√≠fico Usado:
```
"Crea la estructura de microservicios para: api-gateway (puerto 8080), user-service (3001), backup-monitor-service (3002), notification-service (3003), report-service (3004), config-service (3005), billing-service (3006)"
```

### **Paso 2.2: API Gateway y Autenticaci√≥n**

#### Prompt para API Gateway:
```
Implementa el API Gateway que ser√° el punto de entrada √∫nico:

Funcionalidades requeridas:
- Routing a microservicios internos
- Autenticaci√≥n JWT con refresh tokens
- Rate limiting por usuario y endpoint
- Middleware de logging y error handling
- Circuit breaker para resilencia
- Validaci√≥n de requests con Zod

Configura tambi√©n:
- Middleware de CORS
- Compression
- Security headers (helmet)
- Request/response logging

Usa TypeScript strict y sigue principios SOLID.
```

### **Paso 2.3: Servicios Individuales**

#### Prompt Template para Cada Servicio:
```
Implementa el [NOMBRE_SERVICIO] con las siguientes responsabilidades:

**Funcionalidades:**
- [Lista espec√≠fica de funcionalidades]

**Endpoints requeridos:**
- [Lista de endpoints con m√©todos HTTP]

**Modelo de datos:**
- [Esquemas de MongoDB/Mongoose requeridos]

**Integraciones:**
- [Otros servicios con los que debe comunicarse]

**Eventos:**
- [Eventos que debe publicar/escuchar via RabbitMQ]

Incluye:
- Controllers con validaci√≥n Zod
- Services con l√≥gica de negocio
- Models con Mongoose schemas
- Tests unitarios con Jest
- Documentaci√≥n de API

Sigue Clean Architecture y principios SOLID.
```

### **Paso 2.4: Frontend (Microfrontends)**

#### Prompt para Frontend:
```
Crea el frontend usando microfrontends en React con TypeScript:

**Aplicaciones requeridas:**
- admin-dashboard (para administradores)
- user-portal (para usuarios finales)
- installer-app (para instalaci√≥n)

**Stack t√©cnico:**
- React 18 + TypeScript
- Vite para bundling
- Tailwind CSS + Radix UI
- Zustand para estado global
- React Query para datos remotos
- React Router para navegaci√≥n

**Funcionalidades base:**
- Autenticaci√≥n (login/logout)
- Dashboard principal
- Gesti√≥n de usuarios
- Monitoreo en tiempo real (WebSocket)
- Reportes y gr√°ficos

Cada microfrontend debe ser independiente y seguir atomic design.
```

### **Paso 2.5: Testing Comprensivo**

#### Prompt para Testing:
```
Implementa una estrategia de testing completa:

**Tipos de tests requeridos:**
1. Unit tests (Jest + Supertest) para cada servicio
2. Integration tests para flujos entre servicios  
3. E2E tests (Playwright) para flujos de usuario cr√≠ticos
4. Performance tests para endpoints principales

**Configuraci√≥n requerida:**
- Setup de base de datos de testing
- Mocks para servicios externos
- Fixtures de datos de prueba
- Coverage m√≠nimo del 80%
- Tests en pipeline CI/CD

**Tests espec√≠ficos por servicio:**
- [Lista espec√≠fica por cada microservicio]

Incluye ejemplos y documentaci√≥n de c√≥mo ejecutar tests localmente.
```

---

## üöÄ Fase 3: Despliegue a Producci√≥n

### **Paso 3.1: Containerizaci√≥n**

#### Prompt para Docker:
```
Containeriza la aplicaci√≥n completa para despliegue:

1. Crea Dockerfile para cada microservicio optimizado para producci√≥n
2. Configura docker-compose.yml para producci√≥n
3. Setup de multi-stage builds para reducir tama√±o
4. Configuraci√≥n de health checks
5. Variables de entorno y secrets management
6. Optimizaciones de performance

Incluye tambi√©n:
- Dockerfile para frontends con nginx
- Docker para bases de datos (MongoDB, Redis)
- Network configuration entre servicios
- Volume management para persistencia
- Logging configuration
```

### **Paso 3.2: CI/CD Pipeline**

#### Prompt para GitHub Actions:
```
Configura un pipeline CI/CD completo usando GitHub Actions:

**Pipeline stages:**
1. Linting y formateo (ESLint, Prettier)
2. Tests unitarios e integraci√≥n
3. Build de aplicaciones
4. Security scanning (Snyk, npm audit)
5. Build de im√°genes Docker
6. Deploy a staging (rama testing)
7. E2E tests en staging
8. Deploy a producci√≥n (rama main)

**Environments:**
- Development (auto-deploy desde develop)
- Staging (auto-deploy desde testing)
- Production (auto-deploy desde main)

**Features adicionales:**
- Rollback autom√°tico en caso de fallo
- Notificaciones a Slack/Discord
- Deployment approval para producci√≥n
- Gesti√≥n de secrets y variables
```

### **Paso 3.3: Infraestructura Cloud**

#### Prompt para Infrastructure as Code:
```
Configura la infraestructura cloud usando [PROVEEDOR_CLOUD]:

**Componentes requeridos:**
- Kubernetes cluster para microservicios
- Load balancer con SSL termination
- CDN para assets est√°ticos
- Base de datos administrada (MongoDB Atlas)
- Cache administrado (Redis Cloud)
- Message queue (RabbitMQ Cloud)
- Object storage para archivos
- Monitoring stack (Prometheus + Grafana)
- Log aggregation (ELK Stack)

**Configuraci√≥n:**
- Auto-scaling policies
- Backup strategies
- Disaster recovery plan
- Security groups y networking
- SSL certificates management
```

### **Paso 3.4: Monitoreo y Observabilidad**

#### Prompt para Monitoring:
```
Implementa monitoreo completo de la aplicaci√≥n:

**M√©tricas requeridas:**
- Application metrics (response time, error rate)
- Business metrics (usuarios activos, transacciones)
- Infrastructure metrics (CPU, memoria, disk)
- Custom metrics espec√≠ficas del negocio

**Herramientas:**
- Prometheus para m√©tricas
- Grafana para dashboards
- ELK Stack para logs centralizados
- APM tool (New Relic/Datadog)
- Uptime monitoring (Pingdom/StatusPage)

**Alerting:**
- Alertas cr√≠ticas (downtime, errores 5xx)
- Alertas de warning (latencia alta, uso de recursos)
- Escalation policies
- Integration con PagerDuty/OpsGenie
```

---

## ÔøΩÔ∏è Bases de Datos Soportadas

### **Relacionales (ACID Completo)**
- **PostgreSQL**: Aplicaciones empresariales, datos cr√≠ticos, compliance
- **MySQL**: Aplicaciones web tradicionales, WordPress, ecommerce
- **SQLite**: Desarrollo local, aplicaciones m√≥viles, prototipos
- **SQL Server**: Ecosistema Microsoft, aplicaciones enterprise

### **NoSQL (Escalabilidad)**
- **MongoDB**: Documentos, APIs REST, prototipado r√°pido
- **CouchDB**: Sincronizaci√≥n offline, aplicaciones distribuidas
- **DynamoDB**: AWS serverless, alta performance, gaming
- **Firebase**: Aplicaciones m√≥viles, tiempo real, MVP

### **Cache y Sesiones**
- **Redis**: Cache, sesiones, pub/sub, colas de trabajo
- **Memcached**: Cache distribuido simple, alta performance
- **Hazelcast**: Cache empresarial, computaci√≥n distribuida

### **Especializadas**
- **InfluxDB**: Series temporales, IoT, m√©tricas, monitoreo
- **TimescaleDB**: PostgreSQL + series temporales
- **Neo4j**: Grafos, redes sociales, recomendaciones
- **Elasticsearch**: B√∫squeda de texto, analytics, logs
- **Pinecone**: Vectores, embeddings, AI/ML

## üîå MCP (Model Context Protocol) Integrado

### **¬øQu√© es MCP?**
El Model Context Protocol permite que los agentes IA accedan a datos y servicios externos de forma segura y estandarizada.

### **Servidores MCP por Categor√≠a**

#### **ÔøΩüîß Desarrollo y Control de Versiones**
```json
{
  "github": {
    "prop√≥sito": "Gesti√≥n de repositorios, issues, PRs",
    "casos_uso": ["Code review", "Issue tracking", "Release management"],
    "comando": "uvx mcp-server-github"
  },
  "gitlab": {
    "prop√≥sito": "CI/CD, merge requests, pipelines",
    "casos_uso": ["DevOps", "Pipeline automation", "Code collaboration"],
    "comando": "uvx mcp-server-gitlab"
  },
  "linear": {
    "prop√≥sito": "Project management, issue tracking",
    "casos_uso": ["Agile development", "Sprint planning", "Bug tracking"],
    "comando": "npx @linear/mcp-server"
  }
}
```

#### **üóÉÔ∏è Bases de Datos**
```json
{
  "postgresql": {
    "prop√≥sito": "Consultas SQL, schema management",
    "casos_uso": ["Data analysis", "Schema design", "Query optimization"],
    "comando": "uvx mcp-server-postgres"
  },
  "mongodb": {
    "prop√≥sito": "Queries NoSQL, aggregation pipelines",
    "casos_uso": ["Document queries", "Data migration", "Index optimization"],
    "comando": "npx mcp-server-mongodb"
  },
  "redis": {
    "prop√≥sito": "Cache management, pub/sub",
    "casos_uso": ["Performance tuning", "Session management", "Real-time features"],
    "comando": "uvx mcp-server-redis"
  }
}
```

#### **‚òÅÔ∏è Cloud Services**
```json
{
  "aws": {
    "prop√≥sito": "AWS resources management",
    "casos_uso": ["Infrastructure as Code", "Cost optimization", "Security audits"],
    "comando": "uvx mcp-server-aws"
  },
  "gcp": {
    "prop√≥sito": "Google Cloud Platform integration",
    "casos_uso": ["ML/AI services", "BigQuery analytics", "Kubernetes management"],
    "comando": "uvx mcp-server-gcp"
  },
  "azure": {
    "prop√≥sito": "Microsoft Azure services",
    "casos_uso": ["Enterprise integration", "Active Directory", "DevOps"],
    "comando": "uvx mcp-server-azure"
  }
}
```

#### **üîó APIs y Servicios Web**
```json
{
  "rest-api": {
    "prop√≥sito": "Testing y documentaci√≥n de APIs REST",
    "casos_uso": ["API testing", "Documentation generation", "Mock services"],
    "comando": "uvx mcp-server-rest"
  },
  "graphql": {
    "prop√≥sito": "Queries y mutations GraphQL",
    "casos_uso": ["Schema introspection", "Query optimization", "Resolver testing"],
    "comando": "npx mcp-server-graphql"
  },
  "openapi": {
    "prop√≥sito": "Especificaciones OpenAPI/Swagger",
    "casos_uso": ["API design", "Code generation", "Contract testing"],
    "comando": "uvx mcp-server-openapi"
  }
}
```

#### **üìä Productividad y Comunicaci√≥n**
```json
{
  "notion": {
    "prop√≥sito": "Knowledge management, documentation",
    "casos_uso": ["Documentation", "Project wikis", "Knowledge base"],
    "comando": "npx @notion/mcp-server"
  },
  "slack": {
    "prop√≥sito": "Team communication, notifications",
    "casos_uso": ["Automated notifications", "Team updates", "Alert management"],
    "comando": "uvx mcp-server-slack"
  },
  "jira": {
    "prop√≥sito": "Issue tracking, project management",
    "casos_uso": ["Sprint planning", "Bug tracking", "Release management"],
    "comando": "uvx mcp-server-jira"
  }
}
```

### **Configuraci√≥n MCP Recomendada por Proyecto**

#### **üåê Aplicaci√≥n Web Full-Stack**
```json
{
  "recomendado": ["github", "postgresql", "redis", "slack"],
  "opcional": ["aws", "notion", "rest-api"]
}
```

#### **üì± Aplicaci√≥n M√≥vil**
```json
{
  "recomendado": ["github", "firebase", "rest-api", "linear"],
  "opcional": ["aws", "notion", "slack"]
}
```

#### **ü§ñ Proyecto de IA/ML**
```json
{
  "recomendado": ["github", "postgresql", "pinecone", "gcp"],
  "opcional": ["aws", "notion", "jupyter"]
}
```

#### **üìä Analytics y Big Data**
```json
{
  "recomendado": ["github", "postgresql", "influxdb", "elasticsearch"],
  "opcional": ["aws", "gcp", "notion"]
}
```

### **Prompts Optimizados para MCP**

#### **üìä An√°lisis de Base de Datos**
```
Conecta al servidor MCP PostgreSQL y analiza la performance de la base de datos.

Contexto:
- Base de datos: producci√≥n
- Problema: Queries lentas en tabla users
- Tiempo de respuesta actual: >2 segundos

Tareas:
1. Identifica las 10 queries m√°s lentas
2. Analiza los √≠ndices existentes
3. Prop√≥n optimizaciones espec√≠ficas
4. Genera script de migraci√≥n

Usa el MCP server para ejecutar consultas de an√°lisis y proporciona recomendaciones basadas en datos reales.
```

#### **üîß Gesti√≥n de Issues con GitHub**
```
Usa el servidor MCP GitHub para analizar y gestionar issues del proyecto.

Contexto:
- Repositorio: [tu-repo]
- Sprint actual: Sprint 15
- Prioridad: Bugs cr√≠ticos

Tareas:
1. Lista todos los bugs con label "critical"
2. Agrupa por componente afectado
3. Identifica patrones comunes
4. Crea plan de resoluci√≥n con estimaciones
5. Asigna issues a milestone correcto

Proporciona an√°lisis basado en datos reales del repositorio.
```

#### **‚òÅÔ∏è Optimizaci√≥n de Infraestructura AWS**
```
Conecta al servidor MCP AWS para optimizar costos y performance.

Contexto:
- Aplicaci√≥n: [tu-app]
- Regi√≥n: us-east-1
- Problema: Costos elevados y latencia

Tareas:
1. Analiza recursos infrautilizados
2. Identifica oportunidades de reserved instances
3. Revisa configuraci√≥n de auto-scaling
4. Prop√≥n arquitectura optimizada
5. Calcula ahorros proyectados

Usa datos reales de CloudWatch y Cost Explorer.
```

### **Paso 4.1: Documentaci√≥n de Operaciones**

#### Prompt para Runbooks:
```
Crea documentaci√≥n operacional completa:

**Runbooks requeridos:**
- Troubleshooting guide para cada servicio
- Deployment procedures
- Rollback procedures
- Backup and restore procedures
- Disaster recovery plan
- Performance tuning guide
- Security incident response

**Documentaci√≥n para soporte:**
- FAQ para usuarios finales
- Knowledge base para soporte t√©cnico
- Escalation procedures
- SLA definitions y monitoring
```

### **Paso 4.2: Automatizaci√≥n de Soporte**

#### Prompt para Support Automation:
```
Implementa automatizaci√≥n para soporte y mantenimiento:

**Chatbot de soporte:**
- Integration con knowledge base
- Automated ticket creation
- Basic troubleshooting flows
- Escalation to human agents

**Automated maintenance:**
- Database maintenance scripts
- Log rotation y cleanup
- Security patches automation
- Dependency updates (Dependabot)
- Performance optimization scripts

**Self-healing capabilities:**
- Auto-restart failed services
- Auto-scaling based on load
- Circuit breaker patterns
- Graceful degradation
```

### **Paso 4.3: Mejora Continua**

#### Prompt para Continuous Improvement:
```
Establece procesos de mejora continua:

**Analytics y m√©tricas:**
- User behavior analytics
- Performance analytics
- Business KPIs tracking
- Technical debt monitoring

**Feedback loops:**
- User feedback collection
- Team retrospectives automation
- Performance review automation
- Security audit automation

**Innovation pipeline:**
- Feature flag management
- A/B testing framework
- Canary deployment strategy
- Innovation time allocation
```

---

## ‚ö° Prompts Espec√≠ficos por Contexto

### üö® **Resoluci√≥n de Problemas**

#### Cuando algo no funciona:
```
Tengo un problema con [COMPONENTE_ESPEC√çFICO]:

**Error observado:**
[Descripci√≥n exacta del error]

**Contexto:**
- ¬øCu√°ndo empez√≥ a fallar?
- ¬øQu√© cambios se hicieron recientemente?
- ¬øEn qu√© ambiente ocurre?
- ¬øHay logs espec√≠ficos?

**Comportamiento esperado:**
[Lo que deber√≠a pasar]

Por favor ay√∫dame a:
1. Diagnosticar la causa ra√≠z
2. Proponer 3 soluciones posibles
3. Implementar la mejor soluci√≥n
4. Prevenir que vuelva a ocurrir
```

### üîß **Nuevas Funcionalidades**

#### Para agregar features:
```
Necesito implementar una nueva funcionalidad: [DESCRIPCI√ìN]

**Contexto del negocio:**
- ¬øPor qu√© es necesaria?
- ¬øQu√© problema resuelve?
- ¬øQui√©n la va a usar?

**Requisitos funcionales:**
[Lista detallada de qu√© debe hacer]

**Requisitos t√©cnicos:**
- ¬øQu√© servicios se ven afectados?
- ¬øHay integraciones con sistemas externos?
- ¬øHay consideraciones de performance?
- ¬øHay requisitos de seguridad?

Por favor:
1. Analiza el impacto en la arquitectura actual
2. Prop√≥n 3 enfoques de implementaci√≥n
3. Recomienda el mejor enfoque
4. Crea una user story detallada
5. Identifica riesgos y dependencias
```

### üß™ **Optimizaci√≥n y Performance**

#### Para mejorar performance:
```
Necesito optimizar [COMPONENTE/ENDPOINT] que est√° teniendo problemas de performance:

**M√©tricas actuales:**
- Tiempo de respuesta: [X]ms
- Throughput: [X] requests/segundo
- Uso de CPU: [X]%
- Uso de memoria: [X]MB
- Uso de base de datos: [consultas/segundo]

**Objetivo:**
- Tiempo de respuesta: < [X]ms
- Throughput: > [X] requests/segundo

**Constraints:**
- Presupuesto disponible
- Tiempo de implementaci√≥n
- Impacto en otros servicios

Analiza y prop√≥n:
1. Bottlenecks identificados
2. Optimizaciones de c√≥digo
3. Optimizaciones de base de datos
4. Optimizaciones de infraestructura
5. Plan de implementaci√≥n por fases
```

### üõ°Ô∏è **Seguridad**

#### Para auditor√≠as de seguridad:
```
Necesito realizar una auditor√≠a de seguridad completa del sistema:

**√Åreas a revisar:**
- Autenticaci√≥n y autorizaci√≥n
- Validaci√≥n de inputs
- Manejo de secrets
- Comunicaci√≥n entre servicios
- Logs y auditor√≠a
- Configuraci√≥n de infraestructura

**Compliance requerido:**
- [GDPR, SOC2, ISO27001, etc.]

Por favor:
1. Identifica vulnerabilidades potenciales
2. Eval√∫a la implementaci√≥n actual vs mejores pr√°cticas
3. Prop√≥n un plan de remediaci√≥n priorizado
4. Crea checklist para auditor√≠as futuras
5. Recomienda herramientas de monitoring de seguridad
```

---

## üéì Mejores Pr√°cticas

### **‚úÖ DO's - Haz Esto**

#### Contexto y Comunicaci√≥n:
- **S√© espec√≠fico**: "Crea un endpoint POST /api/users que valide email √∫nico" vs "Crea un endpoint de usuarios"
- **Proporciona contexto completo**: Incluye stack tecnol√≥gico, patrones usados, constraints
- **Usa ejemplos**: "Como en el user-service existente" o "Similar a este pattern"
- **Especifica el output esperado**: "Incluye tests unitarios" o "Con documentaci√≥n API"
- **Adapta el prompt al agente**: Claude prefiere contexto detallado, GPT-4 es mejor con ejemplos espec√≠ficos, Gemini funciona bien con estructuras paso a paso

#### Compatibilidad Multi-Agente:
- **GitHub Copilot**: Funciona mejor con comentarios en c√≥digo y autocomplete contextual
- **ChatGPT/GPT-4**: Excelente para arquitectura y explicaciones detalladas
- **Claude**: Superior para an√°lisis de c√≥digo complejo y refactoring
- **Gemini**: Muy bueno para documentaci√≥n y casos de uso
- **Cursor**: Ideal para edici√≥n de c√≥digo en tiempo real
- **v0.dev**: Especializado en componentes UI/UX

#### Gesti√≥n de Iteraciones:
- **Divide en pasos**: No pidas toda la aplicaci√≥n de una vez
- **Valida cada paso**: Revisa el output antes de continuar
- **Refina el contexto**: Mejora las instrucciones basado en resultados anteriores
- **Documenta aprendizajes**: Actualiza las instrucciones AI con nuevos patterns

#### Calidad y Mantenimiento:
- **Exige tests**: Siempre pide tests junto con el c√≥digo
- **Pide documentaci√≥n**: README, comentarios, gu√≠as de API
- **Aplica principios**: Menciona expl√≠citamente SOLID, Clean Architecture
- **Considera performance**: Incluye consideraciones de escalabilidad

### **‚ùå DON'Ts - Evita Esto**

#### Errores Comunes de Contexto:
- **No seas vago**: "Hazme una app" ‚Üí Sin contexto suficiente
- **No asumas conocimiento**: La IA no sabe tu stack completo
- **No ignores errores**: Si algo no funciona, proporciona logs completos
- **No saltes pasos**: Sigue una secuencia l√≥gica de desarrollo

#### Gesti√≥n de Complejidad:
- **No pidas todo junto**: Una aplicaci√≥n completa en un prompt
- **No cambies el contexto constantemente**: Mant√©n consistencia
- **No ignores la arquitectura**: Siempre respeta los patterns establecidos
- **No olvides la documentaci√≥n**: El c√≥digo sin docs es c√≥digo perdido

### **üîÑ Patterns de Iteraci√≥n Efectiva**

#### Pattern 1: Arquitectura ‚Üí Implementaci√≥n ‚Üí Tests
```
1. "Dise√±a la arquitectura para [FEATURE]"
2. "Implementa [COMPONENTE] siguiendo la arquitectura"
3. "Crea tests completos para [COMPONENTE]"
4. "Optimiza y refactoriza basado en tests"
```

#### Pattern 2: MVP ‚Üí Iterate ‚Üí Scale
```
1. "Crea MVP de [FEATURE] con funcionalidades b√°sicas"
2. "Agrega [FUNCIONALIDAD_ESPEC√çFICA] al MVP"
3. "Optimiza para [M√âTRICA_ESPEC√çFICA]"
4. "Escala para soportar [REQUISITO_ESPEC√çFICO]"
```

#### Pattern 3: Problem ‚Üí Analyze ‚Üí Solutions ‚Üí Implement
```
1. "Analiza el problema: [DESCRIPCI√ìN_DETALLADA]"
2. "Prop√≥n 3 soluciones diferentes con pros/cons"
3. "Recomienda la mejor soluci√≥n y justifica"
4. "Implementa la soluci√≥n recomendada paso a paso"
```

---

## üèÜ Ejemplos de Prompts Exitosos Usados en BackupGuard Pro

### **Prompt Inicial del Proyecto (Funciona con cualquier agente IA):**
```
Necesito crear un sistema de monitoreo y gesti√≥n de copias de seguridad multiempresa, viral, f√°cil de instalar, con microservicios y microfrontends en TypeScript, MongoDB y Redis, siguiendo directrices de GEMINI.md.

El sistema debe:
- Ser f√°cil de adoptar por empresas
- Tener instalaci√≥n one-click
- Modelo freemium para viralidad
- Arquitectura escalable y mantenible
- Dashboard en tiempo real
- Alertas inteligentes
- Reportes automatizados

Stack: Node.js/TypeScript, React, MongoDB, Redis, RabbitMQ, Docker, Kubernetes

üìù Nota: Este prompt funcion√≥ exitosamente con GitHub Copilot, ChatGPT-4, y Claude-3.5
```

### **Prompt para Arquitectura (Optimizado para agentes conversacionales):**
```
Dise√±a la arquitectura de microservicios con:
- API Gateway (puerto 8080)
- User Service (3001) - usuarios y organizaciones
- Backup Monitor Service (3002) - monitoreo tiempo real
- Notification Service (3003) - alertas multicanal
- Report Service (3004) - reportes automatizados
- Config Service (3005) - configuraciones
- Billing Service (3006) - Stripe integration

Cada servicio debe tener su propia DB, comunicarse via events (RabbitMQ), seguir Clean Architecture y principios SOLID.

Incluye diagramas C4 para los 4 niveles: System Context, Containers, Components, y Code.

üìù Nota: Funciona especialmente bien con Claude para an√°lisis arquitect√≥nico
```

### **Prompt para Documentaci√≥n (Ideal para Gemini y GPT-4):**
```
Crea documentaci√≥n completa en docs/ con:
- README.md principal
- Architecture/ con diagramas C4 (4 niveles)
- Development/ con setup y patrones
- API/ con especificaciones OpenAPI
- User_guide/ con gu√≠as de usuario

Todo en espa√±ol, markdown profesional, ejemplos pr√°cticos.

Formato: Usa headers jer√°rquicos, code blocks con syntax highlighting, tablas para comparaciones, y badges para status.

üìù Nota: Gemini excele en documentaci√≥n estructurada, GPT-4 en ejemplos pr√°cticos
```

### **Prompt para Instructions AI (Multi-agente):**
```
Genera .github/copilot-instructions.md integrando TODO el contenido de GEMINI.md:
- Principios SOLID y Clean Architecture
- Stack tecnol√≥gico espec√≠fico
- Patrones de microservicios
- Metodolog√≠a Shape Up
- Convenciones de c√≥digo
- Estrategia de testing
- Flujo Git con 3 ramas

Todo en espa√±ol, espec√≠fico para este proyecto.

Compatibilidad: Estas instrucciones deben funcionar con GitHub Copilot, Cursor, Tabnine, y cualquier agente IA de desarrollo.

üìù Nota: Probado exitosamente con m√∫ltiples agentes IA
```

### **Prompts Espec√≠ficos por Agente:**

#### **Para GitHub Copilot (en comentarios de c√≥digo):**
```typescript
// Crear endpoint POST /api/users con validaci√≥n Zod
// Debe incluir: email √∫nico, password hash, role assignment
// Response: user object sin password, JWT token
// Error handling: 400 para validation, 409 para email duplicado
```

#### **Para Cursor (edici√≥n contextual):**
```
Refactoriza esta funci√≥n para seguir principios SOLID:
[C√ìDIGO_EXISTENTE]

Aplica:
- Single Responsibility Principle
- Dependency Injection
- Error handling robusto
- TypeScript strict types
```

#### **Para Claude (an√°lisis profundo):**
```
Analiza este c√≥digo y sugiere mejoras de arquitectura:

[C√ìDIGO_COMPLETO]

Consideraciones:
- Performance y escalabilidad
- Mantenibilidad y testabilidad
- Seguridad y best practices
- Patrones de dise√±o aplicables

Proporciona 3 alternativas de refactoring con pros/cons.
```

#### **Para v0.dev (componentes UI):**
```
Crea un dashboard component en React con:
- Header con navegaci√≥n y user menu
- Sidebar con m√©tricas principales
- Grid de cards con estad√≠sticas de backups
- Tabla de √∫ltimos backups con paginaci√≥n
- Theme: moderno, usar Tailwind CSS + Radix UI

Responsive design, dark/light mode toggle.
```

#### **Para Agentes CLI:**

**GitHub Copilot CLI:**
```bash
# Sugerir comando para setup del proyecto
gh copilot suggest "setup node.js typescript microservices project"

# Explicar comando complejo
gh copilot explain "docker-compose up -d --build --scale api-gateway=2"
```

**Ollama CLI (modelos locales):**
```bash
# Usando CodeLlama para desarrollo
ollama run codellama "Crear funci√≥n TypeScript para validar JWT tokens"

# Usando DeepSeek Coder para refactoring
ollama run deepseek-coder "Refactorizar esta funci√≥n para seguir SOLID principles: [C√ìDIGO]"

# Modelos m√°s recientes disponibles (2025)
ollama run deepseek-r1 "Analizar arquitectura y sugerir mejoras"
ollama run llama3.3 "Crear documentaci√≥n t√©cnica para [COMPONENTE]"
ollama run qwq "Resolver problema complejo de l√≥gica de negocio"
```

**Shell GPT (sgpt):**
```bash
# Generar comando bash desde descripci√≥n
sgpt "create docker-compose file for mongodb redis rabbitmq"

# Debugging de errores
sgpt "fix this error: TypeError: Cannot read property 'user' of undefined"
```

**AI Shell:**
```bash
# Generar y ejecutar comandos complejos
ai "crear estructura de microservicios con carpetas services api-gateway user-service"

# Setup de dependencias
ai "instalar dependencias typescript express mongoose redis para microservicio"
```

**Warp Terminal (IA integrada):**
```bash
# Usar # para activar IA en Warp
# crear script para backup autom√°tico de mongodb

# optimizar dockerfile para aplicaci√≥n node.js
```

---

## üöÄ Conclusi√≥n

Esta gu√≠a te proporciona el framework completo para desarrollar aplicaciones empresariales usando ingenier√≠a de contexto con **cualquier agente IA disponible**. La clave del √©xito est√° en:

1. **Preparaci√≥n**: Tener el contexto claro antes de empezar
2. **Iteraci√≥n**: Desarrollar paso a paso, validando cada etapa
3. **Documentaci√≥n**: Mantener todo documentado para futura referencia
4. **Mejora continua**: Refinar el proceso basado en resultados
5. **Flexibilidad**: Adaptar prompts seg√∫n el agente IA utilizado

### üéØ **Recomendaciones por Tipo de Trabajo:**

- **üìã Planificaci√≥n y Arquitectura**: Claude-3.5 Sonnet, GPT-4
- **üíª Desarrollo de C√≥digo**: GitHub Copilot, Cursor, Tabnine, Cline
- **üé® UI/UX y Componentes**: v0.dev, Claude, GPT-4 con vision
- **üìö Documentaci√≥n**: Gemini Pro, GPT-4, Claude
- **üîç Code Review y Refactoring**: Claude-3.5, GPT-4 Turbo, Continue
- **üß™ Testing y QA**: GPT-4, Phind, GitHub Copilot, Cline
- **üîß DevOps y CI/CD**: Claude, GPT-4, Perplexity AI
- **‚ö° Terminal y Scripts**: GitHub Copilot CLI, Shell GPT, AI Shell
- **üîÑ Automatizaci√≥n**: Ollama (local), Warp Terminal, Fig/Amazon Q
- **üåê Desarrollo Local**: CodeLlama via Ollama, DeepSeek-R1, LM Studio
- **üè† Privacidad/Offline**: Ollama + Open WebUI, Jan, GPT4All, AnythingLLM
- **ü§ñ Desarrollo Aut√≥nomo**: Cline, Continue, Cursor (para tareas complejas)

### üåü **Ventajas de la Metodolog√≠a Universal:**

‚úÖ **No dependes de un solo agente IA**  
‚úÖ **Puedes usar el mejor agente para cada tarea**  
‚úÖ **Tus prompts funcionan en cualquier plataforma**  
‚úÖ **Escalable desde proyectos simples hasta empresariales**  
‚úÖ **Metodolog√≠a probada en proyectos reales**  

**Recuerda**: La IA es tu copiloto experto, pero t√∫ sigues siendo el arquitecto del proyecto. Usa esta gu√≠a como tu roadmap para crear aplicaciones de clase mundial con cualquier agente IA disponible.

### üîó **Recursos Adicionales:**

#### **Agentes Web/Cloud:**
- **ChatGPT**: [chat.openai.com](https://chat.openai.com)
- **Claude (Anthropic)**: [claude.ai](https://claude.ai)
- **Google Gemini**: [gemini.google.com](https://gemini.google.com)
- **Microsoft Copilot**: [copilot.microsoft.com](https://copilot.microsoft.com)
- **Perplexity AI**: [perplexity.ai](https://perplexity.ai)

#### **Agentes IDE Integrados:**
- **GitHub Copilot**: [copilot.github.com](https://copilot.github.com)
- **Cursor**: [cursor.sh](https://cursor.sh)
- **Tabnine**: [tabnine.com](https://tabnine.com)
- **Codeium**: [codeium.com](https://codeium.com)
- **Amazon CodeWhisperer**: [aws.amazon.com/codewhisperer](https://aws.amazon.com/codewhisperer)

#### **Agentes Locales/Privados:**
- **Ollama**: [ollama.ai](https://ollama.ai)
- **LM Studio**: [lmstudio.ai](https://lmstudio.ai)
- **Jan**: [jan.ai](https://jan.ai)
- **GPT4All**: [gpt4all.io](https://gpt4all.io)
- **AnythingLLM**: [anythingllm.com](https://anythingllm.com)
- **Open WebUI**: [openwebui.com](https://openwebui.com)

#### **Extensiones VSCode:**
- **Cline**: [marketplace.visualstudio.com](https://marketplace.visualstudio.com/items?itemName=saoudrizwan.claude-dev)
- **Continue**: [marketplace.visualstudio.com](https://marketplace.visualstudio.com/items?itemName=Continue.continue)

#### **Herramientas CLI:**
- **GitHub CLI + Copilot**: [cli.github.com](https://cli.github.com)
- **Shell GPT**: [github.com/TheR1D/shell_gpt](https://github.com/TheR1D/shell_gpt)
- **AI Shell**: [github.com/BuilderIO/ai-shell](https://github.com/BuilderIO/ai-shell)

#### **Agentes Especializados:**
- **v0.dev (UI)**: [v0.dev](https://v0.dev)
- **Bolt.new (Full-stack)**: [bolt.new](https://bolt.new)
- **Replit (Colaborativo)**: [replit.com](https://replit.com)

---

*√öltima actualizaci√≥n: 16 de agosto de 2025*  
*Proyecto: BackupGuard Pro - Sistema de Monitoreo de Copias de Seguridad*  
*Creado por: Metodolog√≠a Universal de Ingenier√≠a de Contexto*  
*Compatible con: Todos los agentes IA de desarrollo disponibles*
